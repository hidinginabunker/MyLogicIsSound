<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta property="og:image" content="http://hidinginabunker.github.com/MyLogicIsSound/0012/thumbnail.png" />
    <title>MyLogicIsSound | 0012 | web audio test</title>
    <style>
      * { margin:0; padding:0; }

      body {
        background-color: rgb(18,18,18);
        font-family: 'Helvetica' 'sans-serif';
        font-weight: 100;
        color: rgb(244,238,224);
        font-size: 14px;
        padding: 80px;
      }

      h1 {
        font-size: 3em;
        padding-left: 13px;
      }

      a {
        color: rgb(244,238,224);
        text-decoration: underline;
      }

      a.view-source {
        position: absolute;
        bottom: 20px;
        left: 20px;
      }
    </style>
  </head>
  <body>
    <h1>web audio test</h1>
    <a class="view-source" href="https://github.com/hidinginabunker/MyLogicIsSound/blob/master/0012/index.html">Source</a>

    <div class="controls">

      <div class="bufferControls">
        <h2>Sound Buffer Controls</h2>
        <button id="playBufferBtn">Play</button>
      </div>

      <div class="oscControls">
        <h2>Oscillator Controls</h2>
        <button id="playOscBtn">Play</button>
        <button id="pauseOscBtn">Pause</button>
      </div>

    </div>

    <script type="text/javascript">
      /* Notes
         TODO:
          - resample
          - rethumbnail
          - eventually we should think of the audio context as a directed graph
          - A BuffersCollection that lets you get buffers by name when load buffer is called
            it would load to the buffers collection
          - for some fucking reason calling stop() on an AudioSource will keep it from
            ever making a sound again, so you have to dynamically create and destroy 
            AudioSource nodes all the time
          - the MajorScale or music theory objects are great candidates for the use
            of the new getter and setter methods since the values are computed

          1. play multiple oscillators simultaneously
          2. play a triad in a scale
          3. play a melody in that scale at the same time
      */

      // but like only western classical
      var MajorScale = function(tonicFreq) {
        this.scaleIntervals = [2,2,1,2,2,2,1]
        this.scaleFreqs = []
      }

      function getRandomInt (min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function getRandom(min, max) {
          return Math.random() * (max - min) + min;
      }

      var App = function() {

        var self = this;

        window.onload = function() {
          self.init()
        }

      }


      App.prototype.init = function() {

        var self = this

        // set element references
        this.playBufferBtn = document.getElementById('playBufferBtn')
        this.playOscBtn    = document.getElementById('playOscBtn')
        this.pauseOscBtn   = document.getElementById('pauseOscBtn')


        // create the audio context

        try {
          this.ctx = new webkitAudioContext()
        } catch(e) {
          console.log("gross! your browser doesn't support the web audio api")
          console.log(e)
          return
        }

        // create two gain nodes
        //TODO attach two html sliders to these gain nodes
        this.gain1 = this.ctx.createGainNode()
        this.gain2 = this.ctx.createGainNode()

        this.gain1.gain.value = 0.5

        this.gain1.connect(this.ctx.destination)
        this.gain2.connect(this.ctx.destination)

        // create static C minor scale
        this.scale = [
          264.0, //C
          297.0, //D
          316.8, //E
          352.0, //F
          396.0, //G
          442.4, //A
          475.4, //B
          528.0, //C
          594.0  //D
        ]

        this.duration = 600/1000
        this.durationUpperBound = 700/1000
        this.durationLowerBound = 200/1000

        var startTime = this.ctx.currentTime

        for(var i =0; i<6;i++){
          console.log('another iteration', i)
          this.droneFreq = this.scale[getRandomInt(0, this.scale.length)]
          while(this.duration < this.durationUpperBound){
            this.melodyFreq = this.scale[getRandomInt(0, this.scale.length)]
            this.duration += (this.duration*getRandom(0,0.3))

            this.playOsc(this.melodyFreq, startTime, this.duration)
            this.playOsc(this.droneFreq, startTime, this.duration)
            startTime += this.duration
          }

          while(this.duration > this.durationLowerBound){
            this.duration -= this.duration * (getRandom(0,0.3))
            this.melodyFreq = this.scale[getRandomInt(0, this.scale.length)]

            this.playOsc(this.melodyFreq, startTime, this.duration)
            this.playOsc(this.droneFreq, startTime, this.duration)
            startTime += this.duration
          }

        }


        // load sound buffers

        this.loadBuffer('coin.mp3', function(buffer){
          self.buffer = buffer;
        }, function(e){ console.error('error loading sample', e)})


        //TODO, don't attach listeners until buffer is loaded

        // attach event listeners
        this.playBufferBtn.addEventListener('click', function(e){
          self.playBuffer(self.buffer, 0)
        }, false)

        this.playOscBtn.addEventListener('click', function(e){
          console.log('playOscBtn')
          var noteLength = 8
          var scalar = 4
          for(var i = 0; i < noteLength; i++ ) {
            var rest = ((i/noteLength) * (1/2)) * scalar
            console.log(rest)
            self.playOsc(264.0*(i+1),self.ctx.currentTime+rest, 0.1)
          }
        }, false)

        this.pauseOscBtn.addEventListener('click', function(e){
          console.log('hi', e)
          self.stopOsc(0)
        }, false)

      }


      App.prototype.playBars = function(numBars) {
        var startTime = 0
          , eightNoteTime = 1

        for (var bar = 0; bar < numBars; bar++){
          var time = startTime + bar * 8 * eighthNoteTime
        }

      }


      // asynchronously loads an audio file to a buffer
      App.prototype.loadBuffer = function(url, onSuccess, onError) {
        // onSuccess(buffer) passes the audio buffer to the callback
        var self = this
          , req = new XMLHttpRequest();

        req.open('GET', url, true)
        req.responseType = 'arraybuffer' // this is audio data sucka

        req.onload = function() {
          self.ctx.decodeAudioData(req.response, onSuccess, onError)
        }

        req.send()
      }


      // plays a given buffer of samples
      App.prototype.playBuffer = function(buffer, when) {
        var src = this.ctx.createBufferSource()
        src.buffer = buffer;
        src.connect(this.ctx.destination)
        src.start(when)
      }


      App.prototype.playOsc = function(freq, when, duration) {
        var sineOsc = this.ctx.createOscillator()
        sineOsc.type = 'sine'
        sineOsc.frequency.value = freq
        sineOsc.connect(this.gain1)
        sineOsc.start(when)
        sineOsc.stop((when+duration))
      }

      var app = new App();

    </script>
  </body>
</html>
